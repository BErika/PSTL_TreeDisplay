\section{Implémentation}

\subsection{Fonctionnement général}

\begin{frame}
    \frametitle{Paramètres}
    Entrées prises en compte :
    \begin{itemize}
        \item Mots bien parenthésés
        \item XML
        \item DOT %avec l'hypothèse que le graphe représenté est un arbre
    \end{itemize}
    Sorties prises en compte :
    \begin{itemize}
        \item TikZ %(module \LaTeX )
        \item Asymptote %(alternative à TikZ)
        \item NetworkX + Matplotlib %(génère une image ou un PDF en Python)
    \end{itemize}
\end{frame}

\subsection{Parsing}

\begin{frame}[fragile]
    \frametitle{Mots bien parenthésés}
    \begin{block}{Grammaire respectée}
    \begin{alltt}
        ARBRE ::= '(' LABEL NOEUDS ')'
        NOEUDS ::= ARBRE NOEUDS | \(\epsilon\)
        LABEL ::= [a-zA-Z1-9]* | \(\epsilon\)
    \end{alltt}
    \end{block}
    \begin{exampleblock}{Exemple}
    \begin{columns}[t]
	    \column{.2\textwidth}
		\column{.5\textwidth}
		Le parsing de \\
		\centering
	    \begin{alltt}
	    (()(()))
	    \end{alltt}
		\column{.5\textwidth}
		donne l'arbre\\
		~\\
		\includegraphics[width=2cm]{illuGramm}
		\end{columns}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile, allowframebreaks]
    \frametitle{DOT}
    Support d'un sous-langage de DOT.\\
    \begin{block}{Grammaire respectée}
    \begin{alltt}
    DOT ::= STRICT GRAPH ID '{' SEQINST '}'
    STRICT ::= strict | \(\epsilon\)
    GRAPH ::= digraph | graph
    SEQINST ::= INST ';' SEQINST | \(\epsilon\)
    INST ::= ID '[' label = "LABEL" ']' | ID LINK ID
    LINK ::= -- | ->
    ID ::= [0-9]*
    LABEL ::= [a-zA-Z1-9]* | \(\epsilon\)
    \end{alltt}
    \end{block}
    \begin{exampleblock}{Exemple}
	    \begin{columns}[t]
	    \column{.2\textwidth}
		\column{.5\textwidth}
		Le parsing de \\
		\centering
		\begin{alltt}
	    digraph \{
	    1 [label=""];
	    2 [label=""];
	    3 [label=""];
	    4 [label=""];
	    1 -> 2;
	    2 -> 3;
	    3 -> 4;
	    \}
		\end{alltt}
		\column{.5\textwidth}
		donne l'arbre\\
		~\\
		\includegraphics[width=2cm]{illuGramm}
		\end{columns}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile, allowframebreaks]
    \frametitle{XML}
    Support d'un sous-langage de XML.\\
    \begin{block}{Grammaire respectée}
    \begin{alltt}
    XML ::= <?xml version="1.0"?><tree> NOEUDS </tree>
    NOEUDS ::= NOEUD NOEUDS | \(\epsilon\)
    NOEUD ::= <node type=TAG id=ID> NOEUDS </node>
            | <leaf type=TAG id=ID />
    TAG ::= " [a-zA-Z1-9]* "
    ID ::= [0-9]*
    \end{alltt}
    \end{block}
    \begin{exampleblock}{Exemple}
	    \begin{columns}[t]
		\column{.6\textwidth}
		Le parsing de \\
		\centering
	    \begin{alltt}
	    <?xml version="1.0"?>
	    <tree>
	        <node type="" id=1>
	            <leaf type="" id=2 />
	            <node type="" id=3>
	                <leaf type="" id=4 />
	            </node>
	    	    </node>
	    </tree>
    \end{alltt}
		\column{.3\textwidth}
		donne l'arbre\\
		~\\
		\includegraphics[width=2cm]{illuGramm}
		\end{columns}
    \end{exampleblock}
\end{frame}

\subsection{Calcul des coordonnées}

\begin{frame}
	\frametitle{Idée générale}
	\begin{itemize}
		\item Deux passes sur l'arbre
		\begin{enumerate}
			\item Centrer les pères sur les fils + gestion des collisions
			\item Résolution des collisions
		\end{enumerate}
		\item Pourquoi ? Complexité linéaire au lieu de quadratique
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Structure de données}
	\lstinputlisting[language=Python, firstline=23, lastline=37]{../Src/tree.py}
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{Algorithme}
	\framesubtitle{Passe 1}
	\lstinputlisting[language=Python, firstline=43, lastline=72]{../Src/tree.py}
\end{frame}

\begin{frame}
	\frametitle{Algorithme III}
	\framesubtitle{Passe 2}
	\lstinputlisting[language=Python, firstline=77, lastline=87]{../Src/tree.py}
\end{frame}

%    \subsection{Structure d'arbre}
%    
%\paragraph{}Nous avons une structure d'arbre n-aire classique avec une liste pour les enfants ainsi que des attributs pour le calcul de coordonnées et la génération finale. En particulier, les attributs \verb|width| et \verb|height| représente respectivement la plus grande abscisse et la plus grande ordonnée rencontrée dans le sous-arbre. Au niveau de la racine, cela représente la largeur et la hauteur du graphe.

%\paragraph{} Compte-tenu du fait qu'on veut pouvoir travailler sur des arbres de grande taille, le parser bufferise le fichier d'entrée pour ne pas saturer la mémoire en chargeant tout le fichier dans une variable.
%        
%\paragraph{}Le parser XML (cf. \ref{xmlParser})respecte la grammaire ci-dessous. Comme beaucoup de langages de programmation, Python a une librairie dédiée au XML. Nous l'avons utilisée.
%
%        \subsubsection*{Remarques}
%
%\paragraph{} On veut pouvoir utiliser les fichiers générés par \verb|Arbogen| \cite{REF_Arbogen} \footnote{https://github.com/fredokun/arbogen} qui est un générateur d'arbre. Il nous permet de générer des arbres de grandes tailles pour nos tests. C'est en analysant les fichiers fournis par ce générateur que nous avons établi les différences d'interprétations entre \verb|LABEL|, \verb|ID| et \verb|TAG|.
%
%\subparagraph{}Un \verb|LABEL| est une étiquette quelconque sur un n\oe ud, qui peut apparaître à différents endroits de l'arbre. Cela nous assure qu'un mot bien parenthésés ne peut représenter qu'un arbre car seul l'arborescence des parenthèses permet de définir les arcs entre n\oe uds.
%
%\subparagraph{}Un \verb|ID| est un identifiant unique d'un n\oe ud. On remarque alors que la grammaire Dot peut représenter des arbres mais aussi plus généralement des graphes quelconques car les \verb|ID| sont la seule façon de représenter les arcs entre n\oe uds.
%
%\subparagraph{}Un \verb|TAG| correspond en fait à une partie gauche dans la grammaire donnée en entrée à \verb|Arbogen|. Il n'est pas donc unique dans l'arbre et est interprété dans le parser comme un label. Cependant, la grammaire XML comporte aussi des \verb|ID|. Si en plus de considérer l'arborescence des balises XML, on considérait aussi les \verb|ID|, on pourrait aussi représenter des arbres. Ce n'est pas le cas de notre parser XML car on s'intéresse aux arbres.
%
%    \subsection{Fonctionnement de l'algorithme de calcul de coordonnées}
%
%\paragraph{}On décide que la distance minimale entre deux n\oe uds est de $1$ unité selon l'axe des abscisses et celui des ordonnées.
%
%\paragraph{}L'ordonnée d'un n\oe ud est triviale: c'est sa profondeur.
%
%\paragraph{}L’abscisse d'un n\oe ud est un peu plus complexe et demande donc plus de réflexion. 
%
%\subparagraph{}On veut qu'un père soit centré sur ses fils. On commence donc par placer ses fils s'il en a puis on fait la moyenne de l'abscisse de ses $2$ fils extrémaux pour le centrer. 
%
%\subparagraph{}Si un n\oe ud n'a pas de fils, on le place à $1$ de son frère gauche. D'un point de vue de l'architecture, on a donc besoin d'une structure qui, à profondeur \verb|p| mémorise la prochaine place disponible (ou au choix la dernière place utilisée).
%
%\subparagraph{}Si un n\oe ud a des fils, il se peut qu'en calculant son abscisse en fonction de ses fils on se retrouve avec un n\oe ud qui est trop proche de son frère gauche comme dans l'exemple ci-dessous. 
%
%\subparagraph{} Considérons l'arbre suivant: \verb|(root (n11) (n12) (n13 (n21) (n22) (n23)))|. \\
%\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
%    \hline
%     & \multicolumn{2}{|c|}{root} & \multicolumn{2}{|c|}{n11} & \multicolumn{2}{|c|}{n12} & \multicolumn{2}{|c|}{n13} & \multicolumn{2}{|c|}{n21} & \multicolumn{2}{|c|}{n22} & \multicolumn{2}{|c|}{n23}\\ \hline
%    & x & y & x & y & x & y & x & y & x & y & x & y & x & y \\ \hline
%    Initialement & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Appel sur root & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Appel sur n11 & -1 & 0 & 0 & 1 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Retour sur root & -1 & 0 & 0 & 1 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Appel sur n12 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Retour sur root & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Appel sur n13 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & -1 & 0 & -1 & 0 & -1 & 0 \\ \hline
%    Appel sur n21 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & 0 & 2 & -1 & 0 & -1 & 0 \\ \hline
%    Retour sur n13 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & 0 & 2 & -1 & 0 & -1 & 0 \\ \hline
%    Appel sur n22 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & 0 & 2 & 1 & 2 & -1 & 0 \\ \hline
%    Retour sur n13 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & 0 & 2 & 1 & 2 & -1 & 0 \\ \hline
%    Appel sur n23 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & 0 & 2 & 1 & 2 & 2 & 2 \\ \hline
%    Retour sur n13 & -1 & 0 & 0 & 1 & 1 & 1 & -1 & 0 & 0 & 2 & 1 & 2 & 2 & 2 \\ \hline
%\end{tabular}\\
%La position ensuite calculée pour \verb|n13| est $1$. Or il y a déjà \verb|n12| à cet endroit. La première place disponible à profondeur $1$ est $2$. On va donc devoir effectuer un décalage de $1$.
%
%\begin{figure}[h] \centering \resizebox {!}{4cm} {
%\begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}, node distance=1pt]
%\input {exemple1_avant}
%\end{tikzpicture}}
%\caption{Résultat de l'exemple à la fin de l'étape 1.}
%\end{figure}
%
%\subparagraph{}On compare la position calculée avec la première position disponible et on prend le maximum. Si la position calculée n'est pas celle retenue, le père n'est plus centré au milieu de ses fils. On mémorise donc le décalage effectué pour ce père pour ensuite l'appliquer à ses sous-arbres dans un second temps pour des raisons de complexité. En effet, si on faisait chaque décalage lorsqu'il se présentait, le décalage serait quadratique car il y a potentiellement un décalage pour chaque ancêtre d'un n\oe uds.
%    
%\lstinputlisting[language=Python, firstline=43, lastline=72]{../Src/tree.py}
%
%\subparagraph{}Il faut ensuite appliquer récursivement les décalages calculés lors de la première passe. On calcule à la même occasion la hauteur et la largeur de l'image pour pouvoir connaître le ratio de l'image lors de la génération.
%
%\lstinputlisting[language=Python, firstline=77, lastline=87]{../Src/tree.py}
%
%\subparagraph{}Le résultat final est le suivant:
%
%\begin{figure}[h] \centering \resizebox {!}{5cm} {
%\begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}, node distance=1pt]
%\input {exemple1_apres}
%\end{tikzpicture}}
%\caption{Résultat de l'exemple à la fin de l'étape 2.}
%\end{figure}
%
%    \subsection{Fonctionnement de la génération du code}
%    
%        \subsubsection*{TikZ}
%\lstinputlisting[language=Python, firstline=20]{../Src/toTikZ.py}
%        
%        \subsubsection*{Asymptote}
%\lstinputlisting[language=Python, firstline=20]{../Src/toAsymptote.py}
%        
%        \subsubsection*{Autre}
%\lstinputlisting[language=Python, firstline=20]{../Src/toNetworkX.py}
%
%\section{Complexité}
%
%\paragraph{}On suppose que la taille des labels est bornée. On note $n$ le nombre de n\oe uds dans l'arbre. Dans ce cas:
%
%\begin{enumerate}
%    \item Le parsing d'un fichier est en $O(n)$ car on parcours linéairement le fichier.
%    \item Le calcul des coordonnées est en $O(n)$ car on effectue $2$ passes sur l'arbre et lors de chaque passe on visite une et une seule fois chaque n\oe ud.
%    \item La génération du fichier de sortie est en $O(n)$ car on visite une unique fois chaque n\oe ud pour écrire ses coordonnées dans le fichier de sortie.
%\end{enumerate}
%On a donc une complexité générale en $O(n)$ où $n$ est le nombre de n\oe ud de l'arbre.
%
%\paragraph{}Notons que nous avons supposé que la taille des labels était bornée. Or nous n'avons aucune prise sur la taille des labels du fichier qui nous est passé en entrée. Dans ce cas, même si on borne la taille des labels pour l'affichage, la complexité est dominée par le parsing du fichier d'entrée car on doit lire tous les caractères du fichier.