\chapter{Étude de performances}

	\section{Protocole}

\paragraph{} Avant toute chose, il est important de préciser que les tests effectués ci-dessous ont été réalisés sans aucun label. Comme expliqué précédemment, nous pouvons considérer que si la taille des labels est constante, la complexité des algorithme ne dépendra que du nombre de n\oe uds compris dans l'arbre. C'est donc l'hypothèse que nous faisons ici.

\paragraph{} Nous avons générer environ $2200$ arbres de tailles croissantes en XML avec \verb|Arbogen|. Sur ces $2200$ arbres, nous en gardé aléatoirement $200$ qui constituent notre jeu de tests. Chacun de ces arbres au format XML a été converti aux formats dot et str pour exécuter les parser sur les mêmes arbres. Ensuite, chacune des trois étapes de notre application - à savoir parsing, calcul de coordonnées et génération - a été exécuté $3$ fois et la moyenne a été prise comme valeur de référence.

	\section{Résultats}

	\subsection{Comparaison des temps d'exécution des différents parsers.}
	
\begin{center}

\includegraphics[width=\columnwidth]{execTimeParsers}

\end{center}

\paragraph{} Comme on avait pu le montrer précédemment, on peut observer que les parser ont une complexité linéaire. Ce qu'il ressort également de cette comparaison, c'est que le parser XML est le plus efficace des trois. Cela est certainement du au fait que nous utilisons un module interne à Python pour traiter le fichier d'entrée. En effet, les modules internes des langages sont généralement bien optimisés car ils sont pensés pour le langage concerné. De plus, en à peine une dizaine de secondes, nous pouvons parser un arbre contenant un million de n\oe uds.

	\subsection{Évolution du temps de calcul des coordonées en fonction du nombre de n\oe uds de l'arbre.}
	
\begin{center}

\includegraphics[width=\columnwidth]{execTimeCoord}

\end{center}

\paragraph{} Les tests confirment que notre algorithme est d'une complexité linéaire en temps d'exécution. Nous pouvons également supposer, en observant l'évolution de la courbe, que pour un million de n\oe uds, nous n'aurions besoin que d'à peine une seconde pour effectuer le calcul de coordonnées, ce qui semble un résultat acceptable.

	\subsection{Comparaison des temps d'exécution des différents générateurs.}

\begin{center}

\includegraphics[width=\columnwidth]{execTimeNX}

\end{center}

\paragraph{} Nous comparons tout d'abord les différentes sorties gérées par NetworkX. Nous observons que nous sommes toujours en complexité linéaire, mais que le temps d'exécution est bien supérieur à ce qui a été observé pour les autres générateurs, avec plusieurs secondes pour seulement 5000 n\oe uds. Cependant, la complexité de ce générateur vient en grande partie du fait qu'il génère une image via MatplotLib. Ceci ralentit grandement l'exécution.
	
\begin{center}

\includegraphics[width=\columnwidth]{execTimeGenerators}

\end{center}

\paragraph{} Contrairement à NetworkX, nous générons ici un fichier qui doit être recompilé. Ceci explique certainement en partie le fait que ce générateur soit plus efficace que le générateur NetworkX. Cependant, nous restons toujours en complexité linéaire.

	\subsection{Comparaison des temps d'exécution entre GraphViz et la meilleur combinaison parser/générateur de TreeDisplay.}
	
\begin{center}

\includegraphics[width=\columnwidth]{execTimeGV}

\end{center}

\paragraph{} Nous comparons maintenant TreeDisplay dans sa meilleure combinaison possible de parser et de générateur de sortie, avec le visualiseur que nous avons cité en début de ce rapport : GraphViz. Il en ressort que TreeDisplay est bien plus puissant que GraphViz. Cependant, GraphViz gère des graphes de manière générale et fournit une image en sortie, et nous avons généré un fichier .tex à compiler. Ceci peut expliquer en partie la différence de performance.