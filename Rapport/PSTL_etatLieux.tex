\chapter{État des lieux}

Les articles que nous avons étudié concernaient avant tout la visualisation des arbres binaires de grande taille sans prendre en compte l'ordre des fils. Il en ressort néanmoins plusieurs principes :
\begin{enumerate}
	\item Les ar\^etes de l'arbre ne doivent pas s'intersecter.
	\item Les n\oe{}uds de m\^eme profondeur doivent \^etre dessinés sur la m\^eme ligne horizontale.
	\item Les arbres doivent \^etre dessinés de la manière la plus compacte possible.
	\item Un n\oe{}ud parent doit \^etre centré par rapport à ses fils.
	\item Un sous-arbre doit \^etre dessiné de la même façon, peu importe où il est placé dans l'arbre.
	\item Les n\oe{}uds fils d'un n\oe{}ud père doivent être espacés de manière homogène.
\end{enumerate}
~\\
Un des enjeux soulevés par l'ensemble de ces principes est que les n\oe{}uds ne doivent pas se chevaucher, tout comme les arbres en eux-m\^eme.
~\\
Il existe plusieurs algorithmes permettant de dessiner des arbres de grande taille, mais tous ne respectent pas tous les principes décrits ci-dessus. \\
Par exemple, l'algorithme le plus simple, l'algorithme de Knuth, ne respecte que les deux premiers principes. Cet algorithme décrit déjà une idée de "slot disponible". Mais ce sont Charles Wetherell et Alfred Shannon, en 1979, qui introduiront l'utilisation d'un tableau qui associera à chaque profondeur le prochain slot disponible. Il arrivent ainsi à respecter tous les principes, à l'exception des principes 4 et 5. Ils introduisent malgré tout également l'idée de parcourir l'arbre de bas en haut, plut\^ot que l'inverse, ceci afin de centrer facilement un père selon ses fils. \\
Le principal problème est alors : Comment respecter tous ces principes et traiter le chevauchement d'arbres sans perdre en complexité ? C'est l'algorithme The Mods and the Rockers qui répondra à cette question. Au lieu de reparcourir les sous-arbres pour les décaler afin d'éviter tout chevauchement, on raisonne en deux passes de l'arbre. Lors de la première passe, on mémorise un "modifier" qui indiquera le décallage qui devra \^etre appliqué sur chaque sous-arbre lors de la deuxième passe. \\
Il existe enfin des algorithmes dont le but est surtout d'optimiser les concepts et algorithmes existants. Citons le concept de contour d'arbre, qui permet de ne parcourir que ce contour et donc de ne pas rentrer au c\oe{}r de l'arbre. Ceci est un gain conséquent puisque nous traitons ici des arbres de grande taille, et donc potentiellement très larges.
~\\
Nous allons donc voir à présent comment nous nous sommes inspirées de ces algorithmes afin de généraliser les concepts aux arbres n-aires, et en conservant l'ordre des fils.